# Scene parsing with object instances and occlusion ordering

- 使用对象实例和遮挡排序进行场景分析
- CVPR 2014
- 北卡罗来纳大学教堂山分校，伊利诺伊大学香槟分校

## 摘要
- 本文提出了一种解释场景的方法，即在每个像素处赋予语义标签，并推断各个对象实例的空间范围及其遮挡关系
- 方法：
  - 对于给定测试图像的初始像素标记和一组候选对象目标mask开始，选择一个可以很好地解释图像、同时具有重叠关系和遮挡排序的对象子集（通过贪心法等方法最小化一个整数二次规划问题）
  - 然后交替使用对象预测来精修像素标签
- 在Labelme和SUN数据集的两个具有挑战性的子集上进行评估，效果较好，最大的子集包含45676幅图像和232个类

## Introduction
- 当前一些SOTA的图像分析和语义分割算法，具有一定局限性，包括
  - 语义分割不具备实例（instance）的概念（p.s.这是2014年的论文，实例分割还没有发展）
  - 一些具有local apperence的类相对更容易检测，具有overall shape的较难（个人理解，取决于形变因素和标记因素），且这一类更需要实例的概念，而不仅仅是语义
- 本文根据密集像素标签（dense pixel labels）和由语义masks定义的对象实例来解释场景，取代仅使用边界框的方法，然后根据预测的遮挡关系对对象进行排序
- 在参考文献7的基础上，不仅对待检图片预测被遮挡的背景，还推断所有类之间的联系
- 具体流程如图一
  - 先用参考文献20（作者之前的工作）给出的方法，预测每一个像素的语义得到图a，并同时筛选出一组候选对象mask
  - 取出mask的一些子集来覆盖图像得到图b（天空、马路、连起来的车，都取了一部分子集，此时图a相当于粗略像素标签，图b相当于粗略目标预测）
  - 然后交替优化像素标签和目标预测得到图c和图d，图a和图c对比，连在一起的车被分开了，相当于在参考文献20给出的算法上进一步优化
  - 同时还推断出遮挡顺序图e（图e四张图从左到右深度依次增加，观察到左侧连在一起的三辆车深度正确分离，并且马路深度在车后面）
  - pixel labelling错误的预测出了建筑（红色区域）类，但是实例级的目标预测不需要全像素覆盖（图b和d），因此此处错误预测不影响因为这个区域不会被选出来

## Inference Formulation

### Pixel-level inference
- 对于测试图片，首先寻找全局相似训练图像，然后计算两个像素级指标：相似区域指标、检测器指标，然后用一个SVM整合得到一个一元CRF potential（条件随机场势）
- 本流程来自于参考文献20，是作者CVPR 2013的工作
- 即公式1，给定图像的像素及对应的类，通过SVM后计算sigmoid转为概率值，取负对数
- 通过最小化CRF目标函数（公式2），计算像素标签场，目标函数由一元CRF势（公式1）、对象势、空间平滑项构成，借助阿尔法扩张最小化

### Candidate Instance Generation
- 候选实例生成
- 将对象区分为两大类thing和stuff，thing指人、汽车等需要实例分离的类，stuff指天空、道路等不需分离的类
- 参考文献20中提出的per-exampler detector可以很好的得到thing类的mask，但是stuff类效果不好（图2），例如图3，因为stuff类基本出现在背景中，导致存在遮挡
- 解决方法：单前景标签+复合标签。公式1中的combination SVM训练时，每个像素标签采用default的最前景标签；此外再训练一个non-exclusive combination SVM，训练时，每个像素标签为包含的前后景的所有标签
- 图四表明了两个SVM的对比，前者可以识别到最前景（轮胎，车灯），后者倾向于识别背景

### Instance Scores and Overlap Constraints
- 实例分数和重叠约束
- 实例级推理，需要为每个候选实例分配一个分数，表示其“质量”或与初始像素标签的一致程度（分数越高表示质量越好），并定义实例对之间的重叠约束，分数计算如公式3，对thing和stuff同样有效。
- 利用non-exclusive SVM的原因，不能因为只预测前景而给分数惩罚
- 添加权重修正项，以便后续迭代更新mask，后期选择实例区域目的即为最大化score。选择方式为，先计算修正IOU（不用IOU目的是，对于相连接的物体可以有连续的分数），然后与设定的阈值相比较
- 公式6没有特别看懂

### Instance-level Inference
- 实例级预测，选取候选实例的子集
- 建立二次规划方程公式8并最小化
- 图5给出两种最小化公式8解法的效果，分别为贪心法和CPlex，贪心法速度快精度略低，CPlex速度慢精度高

### Oclusion Ordering
- 对于选择出来的重叠区域，需要预测哪个区域更靠前
- 对重叠mask建图，对于重叠区域添加一对边，然后对所有边赋权，对移除环后的图进行拓扑排序得到深度图（图1e）
- 建图的具体流程没太懂


- 最终公式7和公式2交替优化，作者实验发现一般三轮交替后全部收敛，图6是一个结果图

## 实验结果
- Table1是用的数据集和选取的base（四种架构）
- 指标采用对象和像素的PR准召率
- 本文主要创新点在于2.4中的实例级预测，因此选取table1前两行的base替换这个模块来验证有效性。后两行验证的是贪心和CPlex的差异
- 但是实例级预测模块也有局限性，如图7，水面被标记为道路，导致交替优化时全部出现错误，最终船也检测错误
- 未来工作可以考虑将stuff和thing更加细分，并用更好的实例生成计算公式来进一步优化